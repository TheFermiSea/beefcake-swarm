//! Preflight pipeline composition for orchestrator iterations.
//!
//! Composes the steps that run before each agent invocation into a typed
//! pipeline with deterministic wrappers around LLM outputs:
//!
//! 1. **Context packing** — build WorkPacket from issue + error state
//! 2. **Knowledge enrichment** — query NotebookLM for architectural context / error playbooks
//! 3. **Plan generation** (optional) — LLM-generated plan validated by schema
//! 4. **Verifier hint staging** — extract actionable hints from last verifier report
//! 5. **Prompt assembly** — format the final agent prompt
//!
//! Each stage is a pure function from `PreflightContext → PreflightContext`,
//! making the pipeline testable and deterministic (LLM stages wrap outputs
//! in validated schemas or discard on failure).

use coordination::{ContextPacker, EscalationState, SwarmTier, VerifierReport, WorkPacket};
use serde::{Deserialize, Serialize};
use tracing::{info, warn};

use crate::notebook_bridge::KnowledgeBase;

/// Context threaded through the preflight pipeline.
///
/// Stages read from and extend this struct. The final state
/// is consumed by the orchestrator to build the agent prompt.
#[derive(Debug, Clone)]
pub struct PreflightContext {
    /// The work packet assembled by context packing.
    pub packet: WorkPacket,
    /// Optional plan generated by the plan stage.
    pub plan: Option<ImplementationPlan>,
    /// Verifier hints extracted from the last report.
    pub verifier_hints: Vec<VerifierHint>,
    /// Whether knowledge enrichment succeeded.
    pub kb_enriched: bool,
    /// Stages that ran (for diagnostics).
    pub stages_run: Vec<String>,
}

/// A validated implementation plan from the plan generation stage.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImplementationPlan {
    /// High-level approach description.
    pub approach: String,
    /// Ordered steps to implement.
    pub steps: Vec<PlanStep>,
    /// Files expected to be modified.
    pub target_files: Vec<String>,
    /// Estimated risk level (low/medium/high).
    pub risk: PlanRisk,
}

/// A single step in an implementation plan.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlanStep {
    /// What to do.
    pub description: String,
    /// File to modify (if known).
    pub file: Option<String>,
}

/// Risk assessment for a plan.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum PlanRisk {
    Low,
    Medium,
    High,
}

/// An actionable hint extracted from a verifier report.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerifierHint {
    /// Which gate produced this hint (fmt, clippy, check, test).
    pub gate: String,
    /// The actionable message.
    pub message: String,
    /// Optional file location.
    pub file: Option<String>,
    /// Optional line number.
    pub line: Option<usize>,
}

/// Configuration for the preflight pipeline.
#[derive(Debug, Clone)]
pub struct PreflightConfig {
    /// Whether to run the plan generation stage.
    pub enable_plan_generation: bool,
    /// Whether to run knowledge enrichment.
    pub enable_kb_enrichment: bool,
    /// Maximum number of verifier hints to stage.
    pub max_verifier_hints: usize,
    /// Maximum number of plan steps allowed (schema validation).
    pub max_plan_steps: usize,
}

impl Default for PreflightConfig {
    fn default() -> Self {
        Self {
            enable_plan_generation: false,
            enable_kb_enrichment: true,
            max_verifier_hints: 10,
            max_plan_steps: 15,
        }
    }
}

/// Run the preflight pipeline for the initial iteration (no prior errors).
pub fn run_initial(
    wt_path: &std::path::Path,
    issue_id: &str,
    issue_title: &str,
    tier: SwarmTier,
    knowledge_base: Option<&dyn KnowledgeBase>,
    config: &PreflightConfig,
) -> PreflightContext {
    let packer = ContextPacker::new(wt_path, tier);
    let packet = packer.pack_initial(issue_id, issue_title);

    let mut ctx = PreflightContext {
        packet,
        plan: None,
        verifier_hints: Vec::new(),
        kb_enriched: false,
        stages_run: vec!["context_packing".into()],
    };

    if config.enable_kb_enrichment {
        ctx = stage_knowledge_enrichment(ctx, issue_id, issue_title, None, knowledge_base);
    }

    ctx
}

/// Input for the retry preflight pipeline.
pub struct RetryInput<'a> {
    pub wt_path: &'a std::path::Path,
    pub issue_id: &'a str,
    pub issue_title: &'a str,
    pub tier: SwarmTier,
    pub escalation: &'a EscalationState,
    pub last_report: &'a VerifierReport,
    pub knowledge_base: Option<&'a dyn KnowledgeBase>,
}

/// Run the preflight pipeline for a retry iteration (has prior verifier report).
pub fn run_retry(input: &RetryInput<'_>, config: &PreflightConfig) -> PreflightContext {
    let packer = ContextPacker::new(input.wt_path, input.tier);
    let packet = packer.pack_retry(
        input.issue_id,
        input.issue_title,
        input.escalation,
        input.last_report,
    );

    let mut ctx = PreflightContext {
        packet,
        plan: None,
        verifier_hints: Vec::new(),
        kb_enriched: false,
        stages_run: vec!["context_packing".into()],
    };

    // Extract verifier hints from the last report
    ctx = stage_verifier_hints(ctx, input.last_report, config.max_verifier_hints);

    if config.enable_kb_enrichment {
        ctx = stage_knowledge_enrichment(
            ctx,
            input.issue_id,
            input.issue_title,
            Some(input.last_report),
            input.knowledge_base,
        );
    }

    ctx
}

/// Stage: Extract actionable hints from the last verifier report.
fn stage_verifier_hints(
    mut ctx: PreflightContext,
    report: &VerifierReport,
    max_hints: usize,
) -> PreflightContext {
    let mut hints = Vec::new();

    // Extract hints from each gate's stderr excerpt and parsed errors
    for gate in &report.gates {
        // First, extract from parsed errors (structured)
        for error in &gate.errors {
            hints.push(VerifierHint {
                gate: gate.gate.clone(),
                message: error.message.clone(),
                file: error.file.clone(),
                line: error.line,
            });
            if hints.len() >= max_hints {
                break;
            }
        }
        if hints.len() >= max_hints {
            break;
        }

        // Then, extract from raw stderr if available and no parsed errors
        if gate.errors.is_empty() {
            if let Some(ref stderr) = gate.stderr_excerpt {
                for line in stderr.lines().take(3) {
                    let trimmed = line.trim();
                    if trimmed.is_empty() || trimmed.len() < 5 {
                        continue;
                    }
                    let (file, line_num) = parse_file_line(trimmed);
                    hints.push(VerifierHint {
                        gate: gate.gate.clone(),
                        message: trimmed.to_string(),
                        file,
                        line: line_num,
                    });
                    if hints.len() >= max_hints {
                        break;
                    }
                }
            }
        }
        if hints.len() >= max_hints {
            break;
        }
    }

    info!(
        hint_count = hints.len(),
        "Staged verifier hints for next iteration"
    );
    ctx.verifier_hints = hints;
    ctx.stages_run.push("verifier_hints".into());
    ctx
}

/// Stage: Enrich the work packet with knowledge base context.
fn stage_knowledge_enrichment(
    mut ctx: PreflightContext,
    issue_id: &str,
    issue_title: &str,
    last_report: Option<&VerifierReport>,
    knowledge_base: Option<&dyn KnowledgeBase>,
) -> PreflightContext {
    let Some(kb) = knowledge_base else {
        ctx.stages_run.push("kb_enrichment_skipped".into());
        return ctx;
    };

    // Query Project Brain for architectural context
    let brain_question =
        format!("What architectural context is relevant for: {issue_title}? Issue: {issue_id}");
    match kb.query("project_brain", &brain_question) {
        Ok(response) if !response.is_empty() => {
            ctx.packet.relevant_heuristics.push(response);
            ctx.kb_enriched = true;
            info!("Enriched packet with Project Brain context");
        }
        Ok(_) => {}
        Err(e) => {
            warn!(error = %e, "Project Brain query failed — continuing without");
        }
    }

    // On retries, also query Debugging KB for error patterns
    if let Some(report) = last_report {
        if !ctx.packet.failure_signals.is_empty() {
            let error_desc = ctx
                .packet
                .failure_signals
                .iter()
                .take(3)
                .map(|s| format!("{}: {}", s.category, s.message))
                .collect::<Vec<_>>()
                .join("; ");

            let gates_failed = report.gates_total.saturating_sub(report.gates_passed);
            let debug_question = format!(
                "Known fixes for these errors in {issue_id}: {error_desc}. \
                 Verifier had {} failure signals across {gates_failed} failed gates.",
                report.failure_signals.len(),
            );

            match kb.query("debugging_kb", &debug_question) {
                Ok(response) if !response.is_empty() => {
                    ctx.packet.relevant_playbooks.push(response);
                    ctx.kb_enriched = true;
                    info!("Enriched packet with Debugging KB playbook");
                }
                Ok(_) => {}
                Err(e) => {
                    warn!(error = %e, "Debugging KB query failed — continuing without");
                }
            }
        }
    }

    ctx.stages_run.push("kb_enrichment".into());
    ctx
}

/// Validate a raw plan string against the schema constraints.
///
/// Returns `Some(ImplementationPlan)` if valid, `None` if malformed (fail-closed).
pub fn validate_plan(raw: &str, max_steps: usize) -> Option<ImplementationPlan> {
    match serde_json::from_str::<ImplementationPlan>(raw) {
        Ok(plan) => {
            // Schema validation: enforce bounds
            if plan.steps.is_empty() {
                warn!("Plan validation failed: no steps");
                return None;
            }
            if plan.steps.len() > max_steps {
                warn!(
                    steps = plan.steps.len(),
                    max = max_steps,
                    "Plan validation failed: too many steps"
                );
                return None;
            }
            if plan.approach.trim().is_empty() {
                warn!("Plan validation failed: empty approach");
                return None;
            }
            Some(plan)
        }
        Err(e) => {
            warn!(error = %e, "Plan validation failed: malformed JSON");
            None
        }
    }
}

/// Try to extract file path and line number from a compiler error line.
///
/// Handles patterns like:
/// - `error[E0308]: mismatched types --> src/lib.rs:42:5`
/// - `src/main.rs:10:3: warning: ...`
fn parse_file_line(line: &str) -> (Option<String>, Option<usize>) {
    // Pattern: "... --> file:line:col"
    if let Some(arrow_pos) = line.find("--> ") {
        let after = &line[arrow_pos + 4..];
        return parse_file_colon_line(after);
    }

    // Pattern: "file:line:col: ..."
    if let Some(colon_pos) = line.find(':') {
        let candidate = &line[..colon_pos];
        if candidate.contains('.') && !candidate.contains(' ') {
            return parse_file_colon_line(line);
        }
    }

    (None, None)
}

fn parse_file_colon_line(s: &str) -> (Option<String>, Option<usize>) {
    let parts: Vec<&str> = s.splitn(3, ':').collect();
    if parts.len() >= 2 {
        let file = parts[0].trim().to_string();
        let line = parts[1].trim().parse::<usize>().ok();
        if !file.is_empty() {
            return (Some(file), line);
        }
    }
    (None, None)
}

/// Append verifier hints to the work packet's failure signals or heuristics.
pub fn apply_hints_to_packet(packet: &mut WorkPacket, hints: &[VerifierHint]) {
    if hints.is_empty() {
        return;
    }

    let hint_block = hints
        .iter()
        .map(|h| {
            let loc = match (&h.file, h.line) {
                (Some(f), Some(l)) => format!(" ({f}:{l})"),
                (Some(f), None) => format!(" ({f})"),
                _ => String::new(),
            };
            format!("[{}]{}: {}", h.gate, loc, h.message)
        })
        .collect::<Vec<_>>()
        .join("\n");

    packet
        .relevant_heuristics
        .push(format!("## Verifier Hints\n{hint_block}"));
}

#[cfg(test)]
mod tests {
    use super::*;
    use coordination::SwarmTier;

    /// Construct a minimal WorkPacket for testing.
    fn test_work_packet() -> WorkPacket {
        WorkPacket {
            bead_id: "test-001".into(),
            branch: "test/branch".into(),
            checkpoint: "abc1234".into(),
            objective: "Test objective".into(),
            files_touched: vec![],
            key_symbols: vec![],
            file_contexts: vec![],
            verification_gates: vec![],
            failure_signals: vec![],
            constraints: vec![],
            iteration: 1,
            target_tier: SwarmTier::Worker,
            escalation_reason: None,
            error_history: vec![],
            previous_attempts: vec![],
            iteration_deltas: vec![],
            relevant_heuristics: vec![],
            relevant_playbooks: vec![],
            decisions: vec![],
            generated_at: chrono::Utc::now(),
            max_patch_loc: 150,
            delegation_chain: vec![],
        }
    }

    #[test]
    fn test_preflight_config_defaults() {
        let config = PreflightConfig::default();
        assert!(!config.enable_plan_generation);
        assert!(config.enable_kb_enrichment);
        assert_eq!(config.max_verifier_hints, 10);
        assert_eq!(config.max_plan_steps, 15);
    }

    #[test]
    fn test_validate_plan_valid() {
        let raw = serde_json::to_string(&ImplementationPlan {
            approach: "Fix the borrow checker error".into(),
            steps: vec![PlanStep {
                description: "Add lifetime annotation".into(),
                file: Some("src/lib.rs".into()),
            }],
            target_files: vec!["src/lib.rs".into()],
            risk: PlanRisk::Low,
        })
        .unwrap();

        let plan = validate_plan(&raw, 15).unwrap();
        assert_eq!(plan.steps.len(), 1);
        assert_eq!(plan.risk, PlanRisk::Low);
    }

    #[test]
    fn test_validate_plan_empty_steps_rejected() {
        let raw = serde_json::to_string(&ImplementationPlan {
            approach: "Do nothing".into(),
            steps: vec![],
            target_files: vec![],
            risk: PlanRisk::Low,
        })
        .unwrap();

        assert!(validate_plan(&raw, 15).is_none());
    }

    #[test]
    fn test_validate_plan_too_many_steps_rejected() {
        let steps: Vec<PlanStep> = (0..20)
            .map(|i| PlanStep {
                description: format!("Step {i}"),
                file: None,
            })
            .collect();
        let raw = serde_json::to_string(&ImplementationPlan {
            approach: "Big plan".into(),
            steps,
            target_files: vec![],
            risk: PlanRisk::High,
        })
        .unwrap();

        assert!(validate_plan(&raw, 15).is_none());
    }

    #[test]
    fn test_validate_plan_empty_approach_rejected() {
        let raw = serde_json::to_string(&ImplementationPlan {
            approach: "  ".into(),
            steps: vec![PlanStep {
                description: "Do something".into(),
                file: None,
            }],
            target_files: vec![],
            risk: PlanRisk::Low,
        })
        .unwrap();

        assert!(validate_plan(&raw, 15).is_none());
    }

    #[test]
    fn test_validate_plan_malformed_json() {
        assert!(validate_plan("not json", 15).is_none());
        assert!(validate_plan("{}", 15).is_none());
    }

    #[test]
    fn test_plan_serde_roundtrip() {
        let plan = ImplementationPlan {
            approach: "Refactor module".into(),
            steps: vec![
                PlanStep {
                    description: "Extract function".into(),
                    file: Some("src/main.rs".into()),
                },
                PlanStep {
                    description: "Add tests".into(),
                    file: Some("tests/test.rs".into()),
                },
            ],
            target_files: vec!["src/main.rs".into(), "tests/test.rs".into()],
            risk: PlanRisk::Medium,
        };

        let json = serde_json::to_string_pretty(&plan).unwrap();
        let restored: ImplementationPlan = serde_json::from_str(&json).unwrap();
        assert_eq!(restored.steps.len(), 2);
        assert_eq!(restored.risk, PlanRisk::Medium);
    }

    #[test]
    fn test_parse_file_line_arrow_format() {
        let (file, line) = parse_file_line("error[E0308]: mismatched types --> src/lib.rs:42:5");
        assert_eq!(file.as_deref(), Some("src/lib.rs"));
        assert_eq!(line, Some(42));
    }

    #[test]
    fn test_parse_file_line_colon_format() {
        let (file, line) = parse_file_line("src/main.rs:10:3: warning: unused variable");
        assert_eq!(file.as_deref(), Some("src/main.rs"));
        assert_eq!(line, Some(10));
    }

    #[test]
    fn test_parse_file_line_no_match() {
        let (file, line) = parse_file_line("some random error message");
        assert!(file.is_none());
        assert!(line.is_none());
    }

    #[test]
    fn test_apply_hints_to_packet_empty() {
        let mut packet = test_work_packet();
        apply_hints_to_packet(&mut packet, &[]);
        assert!(packet.relevant_heuristics.is_empty());
    }

    #[test]
    fn test_apply_hints_to_packet_with_hints() {
        let mut packet = test_work_packet();
        let hints = vec![
            VerifierHint {
                gate: "clippy".into(),
                message: "unused variable `x`".into(),
                file: Some("src/lib.rs".into()),
                line: Some(42),
            },
            VerifierHint {
                gate: "test".into(),
                message: "assertion failed".into(),
                file: None,
                line: None,
            },
        ];

        apply_hints_to_packet(&mut packet, &hints);
        assert_eq!(packet.relevant_heuristics.len(), 1);
        let hint_text = &packet.relevant_heuristics[0];
        assert!(hint_text.contains("Verifier Hints"));
        assert!(hint_text.contains("clippy"));
        assert!(hint_text.contains("src/lib.rs:42"));
        assert!(hint_text.contains("test"));
    }

    #[test]
    fn test_verifier_hint_serde_roundtrip() {
        let hint = VerifierHint {
            gate: "check".into(),
            message: "cannot find type `Foo`".into(),
            file: Some("src/bar.rs".into()),
            line: Some(15),
        };

        let json = serde_json::to_string(&hint).unwrap();
        let restored: VerifierHint = serde_json::from_str(&json).unwrap();
        assert_eq!(restored.gate, "check");
        assert_eq!(restored.line, Some(15));
    }

    #[test]
    fn test_preflight_context_stages_tracked() {
        let ctx = PreflightContext {
            packet: test_work_packet(),
            plan: None,
            verifier_hints: Vec::new(),
            kb_enriched: false,
            stages_run: vec!["context_packing".into(), "kb_enrichment".into()],
        };

        assert_eq!(ctx.stages_run.len(), 2);
        assert!(ctx.stages_run.contains(&"context_packing".to_string()));
    }

    #[test]
    fn test_plan_risk_variants() {
        let risks = [PlanRisk::Low, PlanRisk::Medium, PlanRisk::High];
        for risk in risks {
            let json = serde_json::to_string(&risk).unwrap();
            let restored: PlanRisk = serde_json::from_str(&json).unwrap();
            assert_eq!(restored, risk);
        }
    }
}
